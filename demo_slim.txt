initialize() {
    initializeSLiMModelType("nonWF");
    initializeSLiMOptions(dimensionality="xy");
    initializeTreeSeq();
    
    if (!exists("W")) {
      defineConstant("W", 20.0);  // width of the simulated area 
    }
    if (!exists("SIGMA")) {
      defineConstant("SIGMA", 0.5);
    }
    if (!exists("K")) {
      defineConstant("K", 10);  // carrying-capacity per unit square (roughly)
    }

    catn(c("W =", 20));
    catn(c("SIGMA =", 0.5));
    catn(c("K =", 20));
    defineConstant("A", c(0.5,0.0,0.0,0.3,0.9,1.0)); //life-table
    defineConstant("Ar", 20/20);  // height/width of the simulated area
    catn(c("Ar =", 20));
    defineConstant("SD", 0.5);  // sigma_D, the dispersal distance
    catn(c("SD =", 0.5));
    defineConstant("SI", SIGMA);  // sigma_I, the spatial interaction distance
    catn(c("SI =", SI));
    defineConstant("SM", SI);  // sigma_M, the mate choice distance
    catn(c("SM =", SM));
    defineConstant("L", 1);    // mean lifetime at stationarity
    catn(c("L =", 1/L));
    defineConstant("G", 1e8);  // genome length
    catn(c("G =", G));
    defineConstant("FECUN", L); // mean fecundity
    catn(c("FECUN =", FECUN));
    defineConstant("RHO", FECUN/((1+FECUN) * K)); // constant in spatial competition function

    initializeMutationType("m1", 0.5, "g", 0.0, 2);
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, G-1);
    initializeMutationRate(0.0);
    initializeRecombinationRate(1e-9);
    
    // spatial competition
    initializeInteractionType(1, "xy", reciprocal=T, maxDistance=SI * 3);
    i1.setInteractionFunction("n", 1.0/(2*PI*SI^2), SI);
    
    // mate choice
    initializeInteractionType(2, "xy", reciprocal=T, maxDistance=SM * 3);
    i2.setInteractionFunction("n", 1.0/(2*PI*SM^2), SM);
}

reproduction() {
    if (individual.age > 0) {
		mate = i2.drawByStrength(individual, 1);
    if (mate.size()) {
        nOff = rpois(1, FECUN);
        for (i in seqLen(nOff)) {
            pos = individual.spatialPosition + rnorm(2, 0, SD);
            if (p1.pointInBounds(pos)) {
            	offspring = subpop.addCrossed(individual, mate);
          		offspring.setSpatialPosition(pos);
          	}
        }
    }
    return;
}
}

1 early() {
    sim.addSubpop("p1", asInteger(K * Ar * W * W));
    p1.setSpatialBounds(c(0, 0, W, Ar * W));
    p1.individuals.age = rdunif(4000, min = 0, max = 4);
    // random initial positions
    for (ind in p1.individuals) {
        ind.setSpatialPosition(p1.pointUniform());
        ind.tag = 0;
    }
    i1.evaluate();

  // make the spatial map:
    a = 0.5; // marginal habitat
    g = 1.0; // good habitat
    v = 2.0; // very good habitat
    r = 0.4; // ridge
    x = 0.1; // bad habitat
    d = 0.0;
    defineConstant("mapValues",
      c(d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d));
    p1.defineSpatialMap("Kmap", "xy", c(20, 20), mapValues, interpolate=T,
        valueRange=c(x, g), colors=c("red", "yellow"));

}

early() {
    i1.evaluate(p1);
    inds = p1.individuals;
    ages = inds.age;
    mortality = A[ages];
    survival = 1 - mortality;
    competition = i1.totalOfNeighborStrengths(inds);
    // fitness = (1/(1 + RHO * competition))*survival;    
    inds.tagF = competition;
    // adjust for local habitat quality
    for (ind in inds) {
        Klocal = p1.spatialMapValue("Kmap", ind.spatialPosition);
        ind.fitnessScaling = pmin(1.0, 1/(1 + RHO * ind.tagF / Klocal));;}
        
        inds.fitnessScaling = pmax(0.0, survival * inds.fitnessScaling * pmin(sqrt(inds.x/SI), 1.0) * pmin(sqrt(inds.y/SI), 1.0) * pmin(sqrt((W - inds.x)/SI), 1.0) * pmin(sqrt((W - inds.y)/SI), 1.0)); 
; 
 }

1: early(){ 
	if (sim.generation > 3499) {
	catn(sim.generation + ": " + p1.individualCount + ": " + paste(sort(p1.individuals.age)));}
	}

1: late() {
   // to be ready for mate choice
   i2.evaluate(p1);
}

3500: early(){
	sim.treeSeqRememberIndividuals(p1.individuals);}

3587 late() {

// make the spatial map:
    a = 0.5; // marginal habitat
    g = 1.0; // good habitat
    v = 2.0; // very good habitat
    r = 0.4; // ridge
    x = 0.1; // bad habitat
    d = 0.0; // unoccupiable
    defineConstant("mapValues2",
      c(d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d));
    p1.defineSpatialMap("Kmap", "xy", c(20, 20), mapValues2, interpolate=T,
        valueRange=c(d, g), colors=c("red", "yellow")); }
        
3674 late(){

// make the spatial map:
    a = 0.5; // marginal habitat
    g = 1.0; // good habitat
    v = 2.0; // very good habitat
    r = 0.4; // ridge
    x = 0.1; // bad habitat
    d = 0.0; // unoccupiable
    defineConstant("mapValues3",
      c(d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, g, g, g, g, g, g, g, g, g, g, g, g, g, g, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d));
    p1.defineSpatialMap("Kmap", "xy", c(20, 20), mapValues3, interpolate=T,
        valueRange=c(d, g), colors=c("red", "yellow")); }

3761 late() { 

// make the spatial map:
    a = 0.5; // marginal habitat
    g = 1.0; // good habitat
    v = 2.0; // very good habitat
    r = 0.4; // ridge
    x = 0.1; // bad habitat
    d = 0.0; // unoccupiable
    defineConstant("mapValues4",
      c(d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, g, g, g, g, g, g, g, g, g, g, g, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d));
   
    	p1.defineSpatialMap("Kmap", "xy", c(20, 20), mapValues4, interpolate=T,
        valueRange=c(d, g), colors=c("red", "yellow"));
        }

3848 late() {

// make the spatial map:
    a = 0.5; // marginal habitat
    g = 1.0; // good habitat
    v = 2.0; // very good habitat
    r = 0.4; // ridge
    x = 0.1; // bad habitat
    d = 0.0; // unoccupiable
    defineConstant("mapValues5",
      c(d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, g, g, g, g, g, g, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, g, g, g, g, g, g, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, g, g, g, g, g, g, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, g, g, g, g, g, g, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, g, g, g, g, g, g, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, g, g, g, g, g, g, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, g, g, g, g, g, g, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, g, g, g, g, g, g, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d,
        d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d));
   
    	p1.defineSpatialMap("Kmap", "xy", c(20, 20), mapValues5, interpolate=T,
        valueRange=c(d, g), colors=c("red", "yellow"));
        }

3940 late() {
	sim.treeSeqOutput("demo.trees");
	catn("Done.");
	sim.simulationFinished();
	}